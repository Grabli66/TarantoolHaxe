-- Generated by Haxe 3.4.0
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local Array = _hx_e()
local HttpServer = _hx_e()
local IChannel = _hx_e()
local IWriteChannel = _hx_e()
local IReadChannel = _hx_e()
local IRWChannel = _hx_e()
local TcpSocket = _hx_e()
local WebSocket = _hx_e()
local IWSHandler = _hx_e()
local InternalWebSocketHandle = _hx_e()
local Chocolate = _hx_e()
local EReg = _hx_e()
local Handler = _hx_e()
local ErrorHandler = _hx_e()
local Fio = _hx_e()
local HtmlBuilder = _hx_e()
local HttpContext = _hx_e()
local HttpHandler = _hx_e()
local HttpMethod = _hx_e()
local HttpRequest = _hx_e()
local HttpResponse = _hx_e()
local _HttpStatus = {}
_HttpStatus.HttpStatus_Impl_ = _hx_e()
local WorkState = _hx_e()
local InternalHandler = _hx_e()
local JsonResponse = _hx_e()
local Math = _hx_e()
local Peer = _hx_e()
local Reflect = _hx_e()
local Request = _hx_e()
local _Response = {}
_Response.Response_Impl_ = _hx_e()
local AppResponse = _hx_e()
local Route = _hx_e()
local StaticHandler = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local Sys = _hx_e()
local _Tag = {}
_Tag.Tag_Impl_ = _hx_e()
local TagInternal = _hx_e()
local TestZephyr = _hx_e()
local TextTag = _hx_e()
local Type = _hx_e()
local WebSocketHandler = _hx_e()
local haxe = {}
haxe.StackItem = _hx_e()
haxe.IMap = _hx_e()
haxe._EntryPoint = {}
haxe._EntryPoint.Lock = _hx_e()
haxe._EntryPoint.Mutex = _hx_e()
haxe.EntryPoint = _hx_e()
haxe.Log = _hx_e()
haxe.MainEvent = _hx_e()
haxe.MainLoop = _hx_e()
haxe.io = {}
haxe.io.Bytes = _hx_e()
haxe.crypto = {}
haxe.crypto.Base64 = _hx_e()
haxe.crypto.BaseCode = _hx_e()
haxe.crypto.Sha1 = _hx_e()
haxe.ds = {}
haxe.ds.IntMap = _hx_e()
haxe.ds.StringMap = _hx_e()
haxe.io.BytesBuffer = _hx_e()
haxe.io.Eof = _hx_e()
haxe.io.Error = _hx_e()
local lua = {}
lua.Boot = _hx_e()
lua.UserData = _hx_e()
lua.Thread = _hx_e()
local tink = {}
tink._Url = {}
tink._Url.Url_Impl_ = _hx_e()
tink.core = {}
tink.core.TypedError = _hx_e()
tink.core.Outcome = _hx_e()
tink.url = {}
tink.url._Path = {}
tink.url._Path.Path_Impl_ = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self,0);
end
Array.__name__ = true
Array.prototype = _hx_a(
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'pop', function(self) 
    if (self.length == 0) then 
      do return nil end;
    end;
    local rawlength = _G.rawget(self,"length");
    local ret = _G.rawget(self,rawlength - 1);
    _G.rawset(self,"length",rawlength - 1);
    do return ret end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'shift', function(self) 
    if (self.length == 0) then 
      do return nil end;
    end;
    local ret = self[0];
    local _g1 = 0;
    local _g = self.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[i] = self[i + 1];
      end;
    local tmp = self;
    tmp.length = tmp.length - 1;
    do return ret end
  end,
  'slice', function(self,pos,_end) 
    if ((_end == nil) or (_end > self.length)) then 
      _end = self.length;
    else
      if (_end < 0) then 
        _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
      end;
    end;
    if (pos < 0) then 
      pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
    end;
    if ((pos > _end) or (pos > self.length)) then 
      do return _hx_tab_array({ }, 0) end;
    end;
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = _end;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      end;
    do return ret end
  end,
  'unshift', function(self,x) 
    local len = self.length;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[len - i] = self[(len - i) - 1];
      end;
    self[0] = x;
  end,
  'filter', function(self,f) 
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do 
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      if (f(i)) then 
        _g:push(i);
      end;
      end;
    do return _g end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
  ,'__class__',  Array
)

HttpServer.new = function() 
  local self = _hx_new(HttpServer.prototype)
  HttpServer.super(self)
  return self
end
HttpServer.super = function(self) 
  self._socket = TcpSocket.new();
end
HttpServer.__name__ = true
HttpServer.prototype = _hx_a(
  'ProcessClient', function(self,peer,channel) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        haxe.Log.trace("Accept client",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="HttpServer.hx",lineNumber=27,className="HttpServer",methodName="ProcessClient"}));
        while (true) do 
          local request = HttpRequest.new(channel);
          local response = HttpResponse.new(channel);
          local context = HttpContext.new(request,response);
          self._firstHandler:Process(context);
          end;
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      local e = _hx_1
      haxe.Log.trace(e,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="HttpServer.hx",lineNumber=36,className="HttpServer",methodName="ProcessClient"}));
      channel:Close();
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'AddHandler', function(self,handler) 
    if (self._firstHandler == nil) then 
      self._firstHandler = handler;
      self._lastHandler = handler;
    end;
    self._lastHandler.Next = handler;
    self._lastHandler = handler;
  end,
  'Bind', function(self,host,port) 
    local _gthis = self;
    if (self._firstHandler == nil) then 
      _G.error("No handlers",0);
    end;
    self._socket:Bind(host,port,function(p,c) 
      _gthis:ProcessClient(p,c);
    end);
  end
  ,'__class__',  HttpServer
)

IChannel.new = {}
IChannel.__name__ = true
IChannel.prototype = _hx_a(
  
  '__class__',  IChannel
)

IWriteChannel.new = {}
IWriteChannel.__name__ = true
IWriteChannel.__interfaces__ = {IChannel}
IWriteChannel.prototype = _hx_a(
  
  '__class__',  IWriteChannel
)

IReadChannel.new = {}
IReadChannel.__name__ = true
IReadChannel.__interfaces__ = {IChannel}
IReadChannel.prototype = _hx_a(
  
  '__class__',  IReadChannel
)

IRWChannel.new = {}
IRWChannel.__name__ = true
IRWChannel.__interfaces__ = {IWriteChannel,IReadChannel}

TcpSocket.new = function(luaSock) 
  local self = _hx_new(TcpSocket.prototype)
  TcpSocket.super(self,luaSock)
  return self
end
TcpSocket.super = function(self,luaSock) 
  if (luaSock ~= nil) then 
    self._sock = luaSock;
  else
    self._module = require("socket");
  end;
end
TcpSocket.__name__ = true
TcpSocket.__interfaces__ = {IRWChannel}
TcpSocket.prototype = _hx_a(
  'Read', function(self,size) 
    local res = self._sock:read(size);
    if (res == "") then 
      do return nil end;
    end;
    if (res == nil) then 
      _G.error("Socket error",0);
    end;
    do return haxe.io.Bytes.ofString(res) end
  end,
  'Write', function(self,data) 
    local s = data:toString();
    do return self._sock:write(s) end
  end,
  'WriteString', function(self,data) 
    do return self._sock:write(data) end
  end,
  'ReadUntil', function(self,delimeter) 
    local res = self._sock:read(delimeter);
    if (res == "") then 
      do return nil end;
    end;
    if (res == nil) then 
      _G.error("Socket error",0);
    end;
    do return res end
  end,
  'Close', function(self) 
    self._sock:shutdown();
  end,
  'Bind', function(self,host,port,handler) 
    self._sock = self._module.tcp_server(host,port,function(s,e) 
      local tmp = Peer.new();
      handler(tmp,TcpSocket.new(s));
    end);
  end
  ,'__class__',  TcpSocket
)

WebSocket.new = function() 
  local self = _hx_new(WebSocket.prototype)
  WebSocket.super(self)
  return self
end
WebSocket.super = function(self) 
  self.Handle = InternalWebSocketHandle.new();
end
WebSocket.__name__ = true
WebSocket.prototype = _hx_a(
  'OnConnect', function(self,call) 
    self.Handle.ConnectHandle = function(self,p,i) 
      call(p,i);
     end;
  end,
  'OnData', function(self,call) 
    self.Handle.DataHandle = function(self,p,b,c) 
      call(p,b,c);
     end;
  end,
  'OnClose', function(self,call) 
    self.Handle.CloseHandle = function(self,p) 
      call(p);
     end;
  end,
  'OnError', function(self,call) 
    self.Handle.ErrorHandle = function(self,p,e) 
      call(p,e);
     end;
  end
  ,'__class__',  WebSocket
)

IWSHandler.new = {}
IWSHandler.__name__ = true
IWSHandler.prototype = _hx_a(
  
  '__class__',  IWSHandler
)

InternalWebSocketHandle.new = function() 
  local self = _hx_new(InternalWebSocketHandle.prototype)
  InternalWebSocketHandle.super(self)
  return self
end
InternalWebSocketHandle.super = function(self) 
end
InternalWebSocketHandle.__name__ = true
InternalWebSocketHandle.__interfaces__ = {IWSHandler}
InternalWebSocketHandle.prototype = _hx_a(
  'OnConnect', function(self,p,c) 
    if (self.ConnectHandle ~= nil) then 
      self:ConnectHandle(p,c);
    end;
  end,
  'OnData', function(self,p,b,c) 
    if (self.DataHandle ~= nil) then 
      self:DataHandle(p,b,c);
    end;
  end,
  'OnClose', function(self,p) 
    if (self.CloseHandle ~= nil) then 
      self:CloseHandle(p);
    end;
  end,
  'OnError', function(self,p,e) 
    if (self.ErrorHandle ~= nil) then 
      self:ErrorHandle(p,e);
    end;
  end
  ,'__class__',  InternalWebSocketHandle
)

Chocolate.new = function() 
  local self = _hx_new(Chocolate.prototype)
  Chocolate.super(self)
  return self
end
Chocolate.super = function(self) 
  self._httpServer = HttpServer.new();
  self._routes = haxe.ds.StringMap.new();
  self._errorHandlers = haxe.ds.IntMap.new();
end
Chocolate.__name__ = true
Chocolate.prototype = _hx_a(
  'OnHttpError', function(self,c,error) 
    if (self._errorHandlers:exists(error)) then 
      local call = self._errorHandlers:get(error);
      local req = Request.new(c.Request);
      local resp = call(req);
      self:WriteResponse(c,resp);
    end;
  end,
  'WriteResponse', function(self,c,response) 
    c.Response:WriteString(_Response.Response_Impl_.ToString(response));
  end,
  'OnHttpRequest', function(self,c) 
    local found = false;
    local kv = self._routes:iterator();
    while (kv:hasNext()) do 
      local kv1 = kv:next();
      if (kv1:IsMatch(tink._Url.Url_Impl_.toString(c.Request.Resource))) then 
        local req = Request.new(c.Request);
        local resp = kv1:Process(req);
        self:WriteResponse(c,resp);
        found = true;
        break;
      end;
      end;
    if (not found) then 
      _G.error(404,0);
    end;
  end,
  'Get', function(self,pattern,call) 
    local this1 = self._routes;
    local v = Route.new(pattern,call);
    local _this = this1;
    _this.v[pattern] = v;
    _this.k[pattern] = true;
  end,
  'OnError', function(self,err,call) 
    self._errorHandlers:set(err,call);
  end,
  'Listen', function(self,options) 
    if (options.WebSocket ~= nil) then 
      local wshandler = WebSocketHandler.new(Chocolate.WebSocket.Handle);
      self._httpServer:AddHandler(wshandler);
    end;
    local errorHandler = ErrorHandler.new(_hx_bind(self,self.OnHttpError));
    self._httpServer:AddHandler(errorHandler);
    if (options.StaticDir ~= nil) then 
      local staticHandler = StaticHandler.new();
      staticHandler:AddPath(options.StaticDir);
      self._httpServer:AddHandler(staticHandler);
    end;
    local httpHandler = HttpHandler.new(_hx_bind(self,self.OnHttpRequest));
    self._httpServer:AddHandler(httpHandler);
    self._httpServer:Bind("*",options.Port);
  end
  ,'__class__',  Chocolate
)
lua.lib = {}
lua.lib.lrexlib = {}
lua.lib.lrexlib.Rex = _G.require("rex_pcre")

EReg.new = function(r,opt) 
  local self = _hx_new(EReg.prototype)
  EReg.super(self,r,opt)
  return self
end
EReg.super = function(self,r,opt) 
  local ropt = 0;
  local _g1 = 0;
  local _g = opt.length;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local _g2 = opt:charAt(i);
    local _g21 = _g2;
    if (_g21) == "g" then 
      self.global = true;
    elseif (_g21) == "i" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.CASELESS);
    elseif (_g21) == "m" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.MULTILINE);
    elseif (_g21) == "s" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.DOTALL);
    elseif (_g21) == "u" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.UTF8);else end;
    end;
  if (self.global == nil) then 
    self.global = false;
  end;
  self.r = lua.lib.lrexlib.Rex.new(r,ropt);
end
EReg.__name__ = true
EReg.prototype = _hx_a(
  'match', function(self,s) 
    if (s == nil) then 
      do return false end;
    end;
    self.m = _hx_table.pack(self.r:exec(s));
    self.s = s;
    do return self.m[1] ~= nil end
  end,
  'matched', function(self,n) 
    if ((self.m[1] == nil) or (n < 0)) then 
      _G.error("EReg::matched",0);
    else
      if (n == 0) then 
        local k = _G.string.sub(self.s,self.m[1],self.m[2]);
        do return k end;
      else
        if (lua.Boot.__instanceof(self.m[3],_G.table)) then 
          local mn = 2 * (n - 1);
          if (lua.Boot.__instanceof(self.m[3][mn + 1],Bool)) then 
            do return nil end;
          end;
          do return _G.string.sub(self.s,self.m[3][mn + 1],self.m[3][mn + 2]) end;
        else
          _G.error("EReg:matched",0);
        end;
      end;
    end;
  end
  ,'__class__',  EReg
)

Handler.new = {}
Handler.__name__ = true
Handler.prototype = _hx_a(
  'Process', function(self,context) 
  end,
  'CallNext', function(self,context) 
    if (self.Next ~= nil) then 
      self.Next:Process(context);
    end;
  end
  ,'__class__',  Handler
)

ErrorHandler.new = function(call) 
  local self = _hx_new(ErrorHandler.prototype)
  ErrorHandler.super(self,call)
  return self
end
ErrorHandler.super = function(self,call) 
  self._onError = _hx_funcToField(call);
end
ErrorHandler.__name__ = true
ErrorHandler.prototype = _hx_a(
  'ProcessError', function(self,c,err) 
    c.Response:Reset();
    c.Response.Status = err;
    if (self._onError ~= nil) then 
      local _hx_expected_result = {}
      local _hx_status, _hx_result = pcall(function() 
      
          self:_onError(c,err);
         return _hx_expected_result end)
       if not _hx_status then 
        local _hx_1 = _hx_result
        local e = _hx_1
        c.Response:Reset();
        c.Response.Status = 500;
       elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    end;
    c.Response:Close();
  end,
  'Process', function(self,context) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        self:CallNext(context);
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,Int) ) then 
        local e = _hx_1
        self:ProcessError(context,e);
      else
      local e1 = _hx_1
      self:ProcessError(context,500);
       end 
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end
  ,'__class__',  ErrorHandler
)
ErrorHandler.__super__ = Handler
setmetatable(ErrorHandler.prototype,{__index=Handler.prototype})

Fio.new = {}
Fio.__name__ = true
Fio.Exists = function(path) 
  local d = Fio._module.stat(path);
  do return d ~= nil end;
end
Fio.ReadAllBytes = function(path) 
  local d = Fio._module.open(path);
  local s = d:stat();
  local size = s.size;
  local data = d:read(size);
  d:close();
  do return haxe.io.Bytes.ofString(data) end;
end

HtmlBuilder.new = {}
HtmlBuilder.__name__ = true
HtmlBuilder.html = function(options,tags) 
  do return _Tag.Tag_Impl_.FromTag(TagInternal.new("html",options,tags)) end;
end
HtmlBuilder.head = function(options,tags) 
  do return _Tag.Tag_Impl_.FromTag(TagInternal.new("head",options,tags)) end;
end
HtmlBuilder.body = function(options,tags) 
  do return _Tag.Tag_Impl_.FromTag(TagInternal.new("body",options,tags)) end;
end
HtmlBuilder.div = function(options,tags) 
  local tag = TextTag.new("div",options,tags);
  do return _Tag.Tag_Impl_.FromTag(tag) end;
end
HtmlBuilder.p = function(options,tags) 
  do return _Tag.Tag_Impl_.FromTag(TextTag.new("p",options,tags)) end;
end
HtmlBuilder.h1 = function(options,tags) 
  do return _Tag.Tag_Impl_.FromTag(TextTag.new("h1",options,tags)) end;
end

HttpContext.new = function(request,response) 
  local self = _hx_new(HttpContext.prototype)
  HttpContext.super(self,request,response)
  return self
end
HttpContext.super = function(self,request,response) 
  self.Request = request;
  self.Response = response;
end
HttpContext.__name__ = true
HttpContext.prototype = _hx_a(
  
  '__class__',  HttpContext
)

HttpHandler.new = function(call) 
  local self = _hx_new(HttpHandler.prototype)
  HttpHandler.super(self,call)
  return self
end
HttpHandler.super = function(self,call) 
  self._onRequest = _hx_funcToField(call);
end
HttpHandler.__name__ = true
HttpHandler.prototype = _hx_a(
  'Process', function(self,context) 
    if (self._onRequest ~= nil) then 
      self:_onRequest(context);
      context.Response:Close();
    end;
  end
  ,'__class__',  HttpHandler
)
HttpHandler.__super__ = Handler
setmetatable(HttpHandler.prototype,{__index=Handler.prototype})
_hxClasses["HttpMethod"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="get","post","put","delete"},4)}
HttpMethod = _hxClasses["HttpMethod"];
HttpMethod.get = _hx_tab_array({[0]="get",0,__enum__ = HttpMethod},2)

HttpMethod.post = _hx_tab_array({[0]="post",1,__enum__ = HttpMethod},2)

HttpMethod.put = _hx_tab_array({[0]="put",2,__enum__ = HttpMethod},2)

HttpMethod.delete = _hx_tab_array({[0]="delete",3,__enum__ = HttpMethod},2)


HttpRequest.new = function(channel) 
  local self = _hx_new(HttpRequest.prototype)
  HttpRequest.super(self,channel)
  return self
end
HttpRequest.super = function(self,channel) 
  self:ReadHeaders(channel);
  self:ReadBody(channel);
end
HttpRequest.__name__ = true
HttpRequest.prototype = _hx_a(
  'ReadHeaders', function(self,channel) 
    local text = channel:ReadUntil("\n");
    if (text == nil) then 
      _G.error("Connection closed",0);
    end;
    local line = StringTools.trim(text);
    local parts = line:split(" ");
    if (parts.length ~= 3) then 
      _G.error(400,0);
    end;
    self.Method = Type.createEnum(HttpMethod,parts[0]:toLowerCase(),nil);
    self.Resource = tink._Url.Url_Impl_.parse(parts[1]);
    haxe.Log.trace("" .. Std.string(self.Method) .. " " .. tink._Url.Url_Impl_.toString(self.Resource),_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="HttpRequest.hx",lineNumber=66,className="HttpRequest",methodName="ReadHeaders"}));
    self.Headers = haxe.ds.StringMap.new();
    line = StringTools.trim(channel:ReadUntil("\n"));
    while (line.length > 0) do 
      local head = line:split(": ");
      if (head.length < 2) then 
        _G.error(400,0);
      end;
      local v = head[1];
      local _this = self.Headers;
      local key = head[0];
      _this.v[key] = v;
      _this.k[key] = true;
      line = StringTools.trim(channel:ReadUntil("\n"));
      end;
  end,
  'ReadBody', function(self,channel) 
    self.Body = nil;
    if (self.Method == HttpMethod.get) then 
      do return end;
    end;
    local this1 = self.Headers;
    if ((this1.k["Content-Length"] or false)) then 
      local this2 = self.Headers;
      local len = Std.parseInt(this2.v["Content-Length"]);
      self.Body = channel:Read(len);
    else
      local this3 = self.Headers;
      local tmp = this3.v["Transfer-Encoding"] == "chunked";
    end;
  end
  ,'__class__',  HttpRequest
)

HttpResponse.new = function(channel) 
  local self = _hx_new(HttpResponse.prototype)
  HttpResponse.super(self,channel)
  return self
end
HttpResponse.super = function(self,channel) 
  self.Status = 200;
  self.Channel = channel;
  self.Headers = haxe.ds.StringMap.new();
  self:Reset();
end
HttpResponse.__name__ = true
HttpResponse.__interfaces__ = {IWriteChannel}
HttpResponse.prototype = _hx_a(
  'WriteHeaders', function(self) 
    local this1 = self.Headers;
    local v = Std.string(self._buffer.b.length);
    local _this = this1;
    _this.v["Content-Length"] = v;
    _this.k["Content-Length"] = true;
    local _this1 = self.Headers;
    _this1.v["Server"] = "tyrant";
    _this1.k["Server"] = true;
    local k = self.Headers:keys();
    while (k:hasNext()) do 
      local k1 = k:next();
      local this2 = self.Headers;
      local v1 = this2.v[k1];
      self.Channel:WriteString("" .. k1 .. ": " .. v1 .. "\n");
      end;
    self.Channel:WriteString("\n");
  end,
  'Reset', function(self) 
    self._buffer = haxe.io.BytesBuffer.new();
  end,
  'Write', function(self,data) 
    local _this = self._buffer;
    local len = data.length;
    if ((len < 0) or (len > data.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b1 = _this.b;
    local b2 = data.b;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      _this.b:push(b2[i]);
      end;
    do return data.length end
  end,
  'WriteString', function(self,data) 
    local _this = self._buffer;
    local src = haxe.io.Bytes.ofString(data);
    local b1 = _this.b;
    local b2 = src.b;
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      _this.b:push(b2[i]);
      end;
    do return data.length end
  end,
  'Close', function(self) 
    local descr = _HttpStatus.HttpStatus_Impl_.GetDescription(self.Status);
    self.Channel:WriteString("HTTP/1.1 " .. self.Status .. " " .. descr .. "\n");
    self:WriteHeaders();
    self.Channel:Write(self._buffer:getBytes());
  end
  ,'__class__',  HttpResponse
)

_HttpStatus.HttpStatus_Impl_.new = {}
_HttpStatus.HttpStatus_Impl_.__name__ = true
_HttpStatus.HttpStatus_Impl_.GetDescription = function(this1) 
  local this2 = this1;
  if (this2) == 200 then 
    do return "OK" end;
  elseif (this2) == 400 then 
    do return "Bad request" end;
  elseif (this2) == 404 then 
    do return "Not found" end;
  elseif (this2) == 500 then 
    do return "Internal error" end; end;
  do return "Unknown" end;
end
_hxClasses["WorkState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="HANDSHAKE","FRAME_TYPE","LENGTH","DATA","CLOSE"},5)}
WorkState = _hxClasses["WorkState"];
WorkState.HANDSHAKE = _hx_tab_array({[0]="HANDSHAKE",0,__enum__ = WorkState},2)

WorkState.FRAME_TYPE = _hx_tab_array({[0]="FRAME_TYPE",1,__enum__ = WorkState},2)

WorkState.LENGTH = _hx_tab_array({[0]="LENGTH",2,__enum__ = WorkState},2)

WorkState.DATA = _hx_tab_array({[0]="DATA",3,__enum__ = WorkState},2)

WorkState.CLOSE = _hx_tab_array({[0]="CLOSE",4,__enum__ = WorkState},2)


InternalHandler.new = function(context) 
  local self = _hx_new(InternalHandler.prototype)
  InternalHandler.super(self,context)
  return self
end
InternalHandler.super = function(self,context) 
  self._channel = context.Response.Channel;
  self._headers = context.Request.Headers;
  self._state = WorkState.HANDSHAKE;
end
InternalHandler.__name__ = true
InternalHandler.__interfaces__ = {IWriteChannel}
InternalHandler.prototype = _hx_a(
  'decode', function(self,str) 
    local base = haxe.io.Bytes.ofString("0123456789abcdef");
    do return haxe.crypto.BaseCode.new(base):decodeBytes(haxe.io.Bytes.ofString(str:toLowerCase())) end
  end,
  'PushError', function(self,e) 
    if (self.OnError ~= nil) then 
      self:OnError(self._peer,e);
    end;
  end,
  'ProcessHandshake', function(self) 
    local this1 = self._headers;
    local key = this1.v["Sec-WebSocket-Key"] .. "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    local sha = haxe.crypto.Sha1.encode(key);
    local shaKey = haxe.crypto.Base64.encode(self:decode(sha));
    local stringBuffer_length;
    local stringBuffer_b = _hx_e();
    stringBuffer_length = 0;
    local str = "HTTP/1.1 101 Switching Protocols\r\n";
    _G.table.insert(stringBuffer_b,str);
    stringBuffer_length = stringBuffer_length + str.length;
    local str1 = "Upgrade: websocket\r\n";
    _G.table.insert(stringBuffer_b,str1);
    stringBuffer_length = stringBuffer_length + str1.length;
    local str2 = "Connection: Upgrade\r\n";
    _G.table.insert(stringBuffer_b,str2);
    stringBuffer_length = stringBuffer_length + str2.length;
    local str3 = Std.string("Sec-WebSocket-Accept: " .. shaKey .. "\r\n");
    _G.table.insert(stringBuffer_b,str3);
    stringBuffer_length = stringBuffer_length + str3.length;
    local str4 = "\r\n";
    _G.table.insert(stringBuffer_b,str4);
    stringBuffer_length = stringBuffer_length + str4.length;
    self._channel:WriteString(_G.table.concat(stringBuffer_b));
    self._state = WorkState.FRAME_TYPE;
    self:OnConnect(self._peer,self);
  end,
  'ProcessFrame', function(self) 
    local binaryData = self._channel:Read(2);
    local frame = binaryData.b[0];
    self._frameType = _hx_bit.band(frame,15);
    local len = binaryData.b[1];
    self._packLen = 0;
    if ((_hx_bit.band(len,128)) < 1) then 
      _G.error("Only masked message allowed",0);
    end;
    local tmp = self;
    tmp._packLen = tmp._packLen + (_hx_bit.bxor(len,128));
    if (self._packLen > 125) then 
      self._state = WorkState.LENGTH;
    else
      self._state = WorkState.DATA;
    end;
  end,
  'ProcessLength', function(self) 
    if (self._packLen == 126) then 
      local binaryData = self._channel:Read(2);
      local tmp = self;
      tmp._packLen = tmp._packLen + binaryData.b[0];
    else
      if (self._packLen ~= 127) then 
        _G.error("Wrong length type",0);
      end;
    end;
    self._state = WorkState.DATA;
  end,
  'ProcessData', function(self) 
    local binaryData = self._channel:Read(self._packLen + 4);
    local _g = self._frameType;
    local _g1 = _g;
    if (_g1) == 1 or (_g1) == 2 then 
      local mask = binaryData:sub(0,4);
      local data = binaryData:sub(4,binaryData.length - 4);
      local res = haxe.io.Bytes.alloc(data.length);
      local _g11 = 0;
      local _g2 = data.length;
      while (_g11 < _g2) do 
        _g11 = _g11 + 1;
        local i = _g11 - 1;
        local j = _G.math.fmod(i, 4);
        local b = data.b[i];
        local d = _hx_bit.bxor(b,mask.b[j]);
        res.b[i] = _hx_bit.band(d,255);
        end;
      self:OnData(self._peer,res,self);
      self._state = WorkState.FRAME_TYPE;
    elseif (_g1) == 8 then 
      self:OnClose(nil);
      self._state = WorkState.CLOSE;
      self:Disconnect();else
    _G.error("Unknown frame",0); end;
  end,
  'Disconnect', function(self) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        self._channel:Close();
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      local e = _hx_1
      haxe.Log.trace(e,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="InternalHandler.hx",lineNumber=231,className="InternalHandler",methodName="Disconnect"}));
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'Start', function(self) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        local _hx_expected_result = {}
        local _hx_status, _hx_result = pcall(function() 
        
          while (true) do 
            local _g = self._state;
            local _g1 = _g[1];
            if (_g1) == 0 then 
              self:ProcessHandshake();
            elseif (_g1) == 1 then 
              self:ProcessFrame();
            elseif (_g1) == 2 then 
              self:ProcessLength();
            elseif (_g1) == 3 then 
              self:ProcessData();
            elseif (_g1) == 4 then 
              _G.error("_hx__break__"); end;
            
        end
         return _hx_expected_result end)
         if not _hx_status then 
         elseif _hx_result ~= _hx_expected_result then return _hx_result
        end;
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      local e = _hx_1
      self:PushError(e);
      self:Disconnect();
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'Write', function(self,data) 
    local frame = haxe.io.Bytes.alloc(2 + data.length);
    frame.b[0] = 130;
    frame.b[1] = _hx_bit.band(data.length,255);
    frame:blit(2,data,0,data.length);
    do return self._channel:Write(frame) end
  end,
  'WriteString', function(self,data) 
    local frame = haxe.io.Bytes.alloc(2 + data.length);
    frame.b[0] = 129;
    frame.b[1] = _hx_bit.band(data.length,255);
    local dat = haxe.io.Bytes.ofString(data);
    frame:blit(2,dat,0,dat.length);
    do return self._channel:Write(frame) end
  end,
  'Close', function(self) 
    self._channel:Close();
  end
  ,'__class__',  InternalHandler
)

JsonResponse.new = {}
JsonResponse.__name__ = true
JsonResponse.prototype = _hx_a(
  'ToString', function(self) 
    do return "" end
  end
  ,'__class__',  JsonResponse
)

Math.new = {}
Math.__name__ = true
Math.isNaN = function(f) 
  do return f ~= f end;
end

Peer.new = function() 
  local self = _hx_new(Peer.prototype)
  Peer.super(self)
  return self
end
Peer.super = function(self) 
end
Peer.__name__ = true
Peer.prototype = _hx_a(
  
  '__class__',  Peer
)

Reflect.new = {}
Reflect.__name__ = true
Reflect.field = function(o,field) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      do return o[field] end;
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    local e = _hx_1
    do return nil end;
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end

Request.new = function(request) 
  local self = _hx_new(Request.prototype)
  Request.super(self,request)
  return self
end
Request.super = function(self,request) 
  self.Headers = request.Headers;
end
Request.__name__ = true
Request.prototype = _hx_a(
  
  '__class__',  Request
)

_Response.Response_Impl_.new = {}
_Response.Response_Impl_.__name__ = true
_Response.Response_Impl_._new = function(d) 
  local this1 = d;
  do return this1 end;
end
_Response.Response_Impl_.ToString = function(this1) 
  local this2 = this1[1];
  if (this2) == 0 then 
    local s = this1[2];
    do return s end;
  elseif (this2) == 1 then 
    local s1 = this1[2];
    do return s1:ToString() end; end;
end
_hxClasses["AppResponse"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="string","json"},2)}
AppResponse = _hxClasses["AppResponse"];
AppResponse.string = function(s) local _x = _hx_tab_array({[0]="string",0,s,__enum__=AppResponse}, 3); return _x; end 
AppResponse.json = function(s) local _x = _hx_tab_array({[0]="json",1,s,__enum__=AppResponse}, 3); return _x; end 

Route.new = function(pattern,call) 
  local self = _hx_new(Route.prototype)
  Route.super(self,pattern,call)
  return self
end
Route.super = function(self,pattern,call) 
  self._pattern = pattern;
  self._call = function(self,r) 
    do return call(r) end
   end;
end
Route.__name__ = true
Route.prototype = _hx_a(
  'IsMatch', function(self,path) 
    local items1 = path:split("/");
    local items2 = self._pattern:split("/");
    if (items1.length ~= items2.length) then 
      do return false end;
    end;
    local _g = 0;
    while (_g < items2.length) do 
      local s2 = items2[_g];
      _g = _g + 1;
      local _g1 = 0;
      while (_g1 < items1.length) do 
        local s1 = items1[_g1];
        _g1 = _g1 + 1;
        if (s2 ~= s1) then 
          do return false end;
        end;
        end;
      end;
    do return true end
  end,
  'Process', function(self,request) 
    do return self:_call(request) end
  end
  ,'__class__',  Route
)

StaticHandler.new = function() 
  local self = _hx_new(StaticHandler.prototype)
  StaticHandler.super(self)
  return self
end
StaticHandler.super = function(self) 
  self.Paths = haxe.ds.StringMap.new();
end
StaticHandler.__name__ = true
StaticHandler.prototype = _hx_a(
  'AddPath', function(self,path) 
    if (not Fio.Exists(path)) then 
      _G.error("Directory " .. path .. " not exists",0);
    end;
    local parts = path:split("/");
    local parts1 = parts:filter(function(s) 
      if ((s ~= "") and (s ~= ".")) then 
        do return s ~= ".." end;
      else
        do return false end;
      end;
    end);
    local newPath = parts1:join("/");
    local _this = self.Paths;
    _this.v[newPath] = newPath;
    _this.k[newPath] = true;
  end,
  'Process', function(self,context) 
    local path = context.Request.Resource.path;
    local parts = path:split("/");
    local file = parts:pop();
    local parts1 = parts:filter(function(s) 
      if ((s ~= "") and (s ~= ".")) then 
        do return s ~= ".." end;
      else
        do return false end;
      end;
    end);
    local newPath = parts1:join("/");
    local this1 = self.Paths;
    if ((this1.k[newPath] or false)) then 
      local fl = "./" .. newPath .. "/" .. file;
      if (Fio.Exists(fl)) then 
        local data = Fio.ReadAllBytes(fl);
        context.Response:Write(data);
        context.Response:Close();
      else
        _G.error(404,0);
      end;
    else
      self:CallNext(context);
    end;
  end
  ,'__class__',  StaticHandler
)
StaticHandler.__super__ = Handler
setmetatable(StaticHandler.prototype,{__index=Handler.prototype})

String.new = {}
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'toLowerCase', function(self) 
    do return _G.string.lower(self) end
  end,
  'split', function(self,delimiter) 
    local idx = 1;
    local ret = _hx_tab_array({ }, 0);
    local delim_offset = (function() 
      local _hx_1
      if (delimiter.length > 0) then 
      _hx_1 = delimiter.length; else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (delimiter.length > 0) then 
        newidx = _G.string.find(self,delimiter,idx,true);
      else
        if (idx >= self.length) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(self,idx,newidx - 1);
        ret:push(match);
        idx = newidx + delimiter.length;
      else
        ret:push(_G.string.sub(self,idx,_G.string.len(self)));
        idx = nil;
      end;
      end;
    do return ret end
  end,
  'toString', function(self) 
    do return self end
  end,
  'charAt', function(self,index) 
    do return _G.string.sub(self,index + 1,index + 1) end
  end,
  'charCodeAt', function(self,index) 
    do return _G.string.byte(self,index + 1) end
  end,
  'substr', function(self,pos,len) 
    if ((len == nil) or (len > (pos + self.length))) then 
      len = self.length;
    else
      if (len < 0) then 
        len = self.length + len;
      end;
    end;
    if (pos < 0) then 
      pos = self.length + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(self,pos + 1,pos + len) end
  end
  ,'__class__',  String
)

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.int = function(x) 
  do return _hx_bit_clamp(x) end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x,"^ *[%-+]*0[xX][%da-FA-F]*");
  if (hexMatch ~= nil) then 
    do return _G.tonumber(hexMatch:substr(2),16) end;
  else
    local intMatch = _G.string.match(x,"^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = _hx_e();
  self.length = 0;
end
StringBuf.__name__ = true
StringBuf.prototype = _hx_a(
  
  '__class__',  StringBuf
)

StringTools.new = {}
StringTools.__name__ = true
StringTools.startsWith = function(s,start) 
  if (s.length >= start.length) then 
    do return s:substr(0,start.length) == start end;
  else
    do return false end;
  end;
end
StringTools.endsWith = function(s,_end) 
  local elen = _end.length;
  local slen = s.length;
  if (slen >= elen) then 
    do return s:substr(slen - elen,elen) == _end end;
  else
    do return false end;
  end;
end
StringTools.isSpace = function(s,pos) 
  if (((s.length == 0) or (pos < 0)) or (pos >= s.length)) then 
    do return false end;
  end;
  local c = s:charCodeAt(pos);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = s.length;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s,r)) do 
    r = r + 1;
    end;
  if (r > 0) then 
    do return s:substr(r,l - r) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = s.length;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s,(l - r) - 1)) do 
    r = r + 1;
    end;
  if (r > 0) then 
    do return s:substr(0,l - r) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end
StringTools.replace = function(s,sub,by) 
  do return s:split(sub):join(by) end;
end
StringTools.hex = function(n,digits) 
  local s = "";
  local hexChars = "0123456789ABCDEF";
  while (true) do 
    s = hexChars:charAt(_hx_bit.band(n,15)) .. s;
    n = _hx_bit.rshift(n,4);
    if (not (n > 0)) then 
      break;
    end;
    end;
  if (digits ~= nil) then 
    while (s.length < digits) do 
      s = "0" .. s;
      end;
  end;
  do return s end;
end

Sys.new = {}
Sys.__name__ = true
Sys.time = function() 
  do return lua.lib.luasocket.Socket.gettime() end;
end

_Tag.Tag_Impl_.new = {}
_Tag.Tag_Impl_.__name__ = true
_Tag.Tag_Impl_._new = function(tag) 
  local this1 = tag;
  do return this1 end;
end
_Tag.Tag_Impl_.FromTag = function(tag) 
  do return _Tag.Tag_Impl_._new(tag) end;
end
_Tag.Tag_Impl_.ToResponse = function(tag) 
  do return _Response.Response_Impl_._new(AppResponse.string(tag:ToString())) end;
end

TagInternal.new = function(name,options,tags) 
  local self = _hx_new(TagInternal.prototype)
  TagInternal.super(self,name,options,tags)
  return self
end
TagInternal.super = function(self,name,options,tags) 
  self._attributes = haxe.ds.StringMap.new();
  self.Name = name;
  self._tags = (function() 
    local _hx_1
    if (tags ~= nil) then 
    _hx_1 = tags; else 
    _hx_1 = Array.new(); end
    return _hx_1
  end )();
  if (options ~= nil) then 
    if (options.css ~= nil) then 
      local v = options.css;
      local _this = self._attributes;
      _this.v["class"] = v;
      _this.k["class"] = true;
    end;
  end;
end
TagInternal.__name__ = true
TagInternal.prototype = _hx_a(
  'RenderName', function(self) 
    local s = StringBuf.new();
    local str = Std.string("<" .. self.Name);
    _G.table.insert(s.b,str);
    local s1 = s;
    s1.length = s1.length + str.length;
    local i = self._attributes:keys();
    while (i:hasNext()) do 
      local i1 = i:next();
      local str1 = " ";
      _G.table.insert(s.b,str1);
      local s2 = s;
      s2.length = s2.length + str1.length;
      local this1 = self._attributes;
      local str2 = Std.string("" .. i1 .. "=\"" .. this1.v[i1] .. "\"");
      _G.table.insert(s.b,str2);
      local s3 = s;
      s3.length = s3.length + str2.length;
      end;
    local str3 = ">";
    _G.table.insert(s.b,str3);
    local s4 = s;
    s4.length = s4.length + str3.length;
    do return s end
  end,
  'RenderChilds', function(self,s) 
    local _g = 0;
    local _g1 = self._tags;
    while (_g < _g1.length) do 
      local t = _g1[_g];
      _g = _g + 1;
      local str = Std.string(t:ToString());
      _G.table.insert(s.b,str);
      local s1 = s;
      s1.length = s1.length + str.length;
      end;
  end,
  'CloseTag', function(self,s) 
    local str = Std.string("</" .. self.Name .. ">");
    _G.table.insert(s.b,str);
    local s1 = s;
    s1.length = s1.length + str.length;
  end,
  'ToString', function(self) 
    local s = self:RenderName();
    self:RenderChilds(s);
    self:CloseTag(s);
    do return _G.table.concat(s.b) end
  end
  ,'__class__',  TagInternal
)

TestZephyr.new = {}
TestZephyr.__name__ = true
TestZephyr.main = function() 
  Chocolate.App:Get("/",function(req) 
    local tmp = HtmlBuilder.head();
    local tmp1 = HtmlBuilder.p(_hx_o({__fields__={text=true},text="Hello world!"}));
    do return _Tag.Tag_Impl_.ToResponse(HtmlBuilder.html(nil,_hx_tab_array({[0]=tmp, HtmlBuilder.body(nil,_hx_tab_array({[0]=HtmlBuilder.div(_hx_o({__fields__={text=true,css=true},text="GOOD",css="shit"}),_hx_tab_array({[0]=tmp1 }, 1)), HtmlBuilder.div() }, 2)) }, 2))) end;
  end);
  Chocolate.App:OnError(404,function(req1) 
    do return _Tag.Tag_Impl_.ToResponse(HtmlBuilder.html(nil,_hx_tab_array({[0]=HtmlBuilder.head(), HtmlBuilder.body(nil,_hx_tab_array({[0]=HtmlBuilder.h1(_hx_o({__fields__={text=true},text="Not found!"})) }, 1)) }, 2))) end;
  end);
  Chocolate.WebSocket:OnConnect(function(p,c) 
    haxe.Log.trace("CONNECTED",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="TestZephyr.hx",lineNumber=30,className="TestZephyr",methodName="main"}));
    c:WriteString("GOOD");
  end);
  Chocolate.WebSocket:OnData(function(p1,data,c1) 
    haxe.Log.trace(data:toString(),_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="TestZephyr.hx",lineNumber=35,className="TestZephyr",methodName="main"}));
  end);
  Chocolate.WebSocket:OnClose(function(p2) 
    haxe.Log.trace("CLOSE",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="TestZephyr.hx",lineNumber=39,className="TestZephyr",methodName="main"}));
  end);
  Chocolate.WebSocket:OnError(function(p3,e) 
    haxe.Log.trace(e,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="TestZephyr.hx",lineNumber=43,className="TestZephyr",methodName="main"}));
  end);
  Chocolate.App:Listen(_hx_o({__fields__={Port=true,StaticDir=true,WebSocket=true},Port=8081,StaticDir="./out/media",WebSocket=true}));
end

TextTag.new = function(name,options,tags) 
  local self = _hx_new(TextTag.prototype)
  TextTag.super(self,name,options,tags)
  return self
end
TextTag.super = function(self,name,options,tags) 
  TagInternal.super(self,name,options,tags);
  self.Text = "";
  if (options ~= nil) then 
    self.Text = (function() 
      local _hx_1
      if (options.text ~= nil) then 
      _hx_1 = options.text; else 
      _hx_1 = ""; end
      return _hx_1
    end )();
  end;
end
TextTag.__name__ = true
TextTag.prototype = _hx_a(
  'ToString', function(self) 
    local s = self:RenderName();
    if (self.Text ~= "") then 
      local str = Std.string(self.Text);
      _G.table.insert(s.b,str);
      local s1 = s;
      s1.length = s1.length + str.length;
    end;
    self:RenderChilds(s);
    self:CloseTag(s);
    do return _G.table.concat(s.b) end
  end
  ,'__class__',  TextTag
)
TextTag.__super__ = TagInternal
setmetatable(TextTag.prototype,{__index=TagInternal.prototype})

Type.new = {}
Type.__name__ = true
Type.createEnum = function(e,constr,params) 
  local f = Reflect.field(e,constr);
  if (f == nil) then 
    _G.error("No such constructor " .. constr,0);
  end;
  if (Reflect.isFunction(f)) then 
    if (params == nil) then 
      _G.error("Constructor " .. constr .. " need parameters",0);
    end;
    local func = f;
    if ((params == nil) or (params.length == 0)) then 
      do return func(nil) end;
    else
      local self_arg = false;
      local new_args = ({});
      local _g1 = 0;
      local _g = params.length;
      while (_g1 < _g) do 
        _g1 = _g1 + 1;
        local i = _g1 - 1;
        new_args[i + 1] = params[i];
        end;
      if (self_arg) then 
        do return func(nil,_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
      else
        do return func(_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
      end;
    end;
  end;
  if ((params ~= nil) and (params.length ~= 0)) then 
    _G.error("Constructor " .. constr .. " does not need parameters",0);
  end;
  do return f end;
end

WebSocketHandler.new = function(handler) 
  local self = _hx_new(WebSocketHandler.prototype)
  WebSocketHandler.super(self,handler)
  return self
end
WebSocketHandler.super = function(self,handler) 
  self._handler = handler;
end
WebSocketHandler.__name__ = true
WebSocketHandler.prototype = _hx_a(
  'Process', function(self,context) 
    local this1 = context.Request.Headers;
    if ((this1.k["Upgrade"] or false)) then 
      local ih = InternalHandler.new(context);
      ih.OnConnect = _hx_funcToField((function() local __=self._handler; return _hx_bind(__,__.OnConnect) end)());
      ih.OnData = _hx_funcToField((function() local __=self._handler; return _hx_bind(__,__.OnData) end)());
      ih.OnClose = _hx_funcToField((function() local __=self._handler; return _hx_bind(__,__.OnClose) end)());
      ih.OnError = _hx_funcToField((function() local __=self._handler; return _hx_bind(__,__.OnError) end)());
      ih:Start();
    else
      self:CallNext(context);
    end;
  end
  ,'__class__',  WebSocketHandler
)
WebSocketHandler.__super__ = Handler
setmetatable(WebSocketHandler.prototype,{__index=Handler.prototype})
_hxClasses["haxe.StackItem"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="CFunction","Module","FilePos","Method","LocalFunction"},5)}
haxe.StackItem = _hxClasses["haxe.StackItem"];
haxe.StackItem.CFunction = _hx_tab_array({[0]="CFunction",0,__enum__ = haxe.StackItem},2)

haxe.StackItem.Module = function(m) local _x = _hx_tab_array({[0]="Module",1,m,__enum__=haxe.StackItem}, 3); return _x; end 
haxe.StackItem.FilePos = function(s,file,line) local _x = _hx_tab_array({[0]="FilePos",2,s,file,line,__enum__=haxe.StackItem}, 5); return _x; end 
haxe.StackItem.Method = function(classname,method) local _x = _hx_tab_array({[0]="Method",3,classname,method,__enum__=haxe.StackItem}, 4); return _x; end 
haxe.StackItem.LocalFunction = function(v) local _x = _hx_tab_array({[0]="LocalFunction",4,v,__enum__=haxe.StackItem}, 3); return _x; end 

haxe.IMap.new = {}
haxe.IMap.__name__ = true
haxe.IMap.prototype = _hx_a(
  
  '__class__',  haxe.IMap
)

haxe._EntryPoint.Lock.new = function() 
  local self = _hx_new(haxe._EntryPoint.Lock.prototype)
  haxe._EntryPoint.Lock.super(self)
  return self
end
haxe._EntryPoint.Lock.super = function(self) 
end
haxe._EntryPoint.Lock.__name__ = true
haxe._EntryPoint.Lock.prototype = _hx_a(
  
  '__class__',  haxe._EntryPoint.Lock
)

haxe._EntryPoint.Mutex.new = function() 
  local self = _hx_new(haxe._EntryPoint.Mutex.prototype)
  haxe._EntryPoint.Mutex.super(self)
  return self
end
haxe._EntryPoint.Mutex.super = function(self) 
end
haxe._EntryPoint.Mutex.__name__ = true
haxe._EntryPoint.Mutex.prototype = _hx_a(
  
  '__class__',  haxe._EntryPoint.Mutex
)

haxe.EntryPoint.new = {}
haxe.EntryPoint.__name__ = true
haxe.EntryPoint.processEvents = function() 
  while (true) do 
    local _this = haxe.EntryPoint.mutex;
    local f = haxe.EntryPoint.pending:shift();
    local _this1 = haxe.EntryPoint.mutex;
    if (f == nil) then 
      break;
    end;
    f();
    end;
  if ((haxe.MainLoop.pending == nil) and (haxe.EntryPoint.threadCount == 0)) then 
    do return -1 end;
  end;
  do return haxe.MainLoop.tick() end;
end
haxe.EntryPoint.run = function() 
  while (true) do 
    local nextTick = haxe.EntryPoint.processEvents();
    if (nextTick < 0) then 
      break;
    end;
    if (nextTick > 0) then 
      local _this = haxe.EntryPoint.sleepLock;
    end;
    end;
end

haxe.Log.new = {}
haxe.Log.__name__ = true
haxe.Log.trace = function(v,infos) 
  local str = nil;
  if (infos ~= nil) then 
    str = infos.fileName .. ":" .. infos.lineNumber .. ": " .. Std.string(v);
    if (infos.customParams ~= nil) then 
      str = str .. ("," .. infos.customParams:join(","));
    end;
  else
    str = v;
  end;
  if (str == nil) then 
    str = "null";
  end;
  _hx_print(str);
end

haxe.MainEvent.new = {}
haxe.MainEvent.__name__ = true
haxe.MainEvent.prototype = _hx_a(
  
  '__class__',  haxe.MainEvent
)

haxe.MainLoop.new = {}
haxe.MainLoop.__name__ = true
haxe.MainLoop.sortEvents = function() 
  local list = haxe.MainLoop.pending;
  if (list == nil) then 
    do return end;
  end;
  local insize = 1;
  local nmerges;
  local psize = 0;
  local qsize = 0;
  local p;
  local q;
  local e;
  local tail;
  while (true) do 
    p = list;
    list = nil;
    tail = nil;
    nmerges = 0;
    while (p ~= nil) do 
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      local _g1 = 0;
      local _g = insize;
      while (_g1 < _g) do 
        _g1 = _g1 + 1;
        local i = _g1 - 1;
        psize = psize + 1;
        q = q.next;
        if (q == nil) then 
          break;
        end;
        end;
      qsize = insize;
      while ((psize > 0) or ((qsize > 0) and (q ~= nil))) do 
        if (psize == 0) then 
          e = q;
          q = q.next;
          qsize = qsize - 1;
        else
          if (((qsize == 0) or (q == nil)) or ((p.priority > q.priority) or ((p.priority == q.priority) and (p.nextRun <= q.nextRun)))) then 
            e = p;
            p = p.next;
            psize = psize - 1;
          else
            e = q;
            q = q.next;
            qsize = qsize - 1;
          end;
        end;
        if (tail ~= nil) then 
          tail.next = e;
        else
          list = e;
        end;
        e.prev = tail;
        tail = e;
        end;
      p = q;
      end;
    tail.next = nil;
    if (nmerges <= 1) then 
      break;
    end;
    insize = insize * 2;
    end;
  list.prev = nil;
  haxe.MainLoop.pending = list;
end
haxe.MainLoop.tick = function() 
  haxe.MainLoop.sortEvents();
  local e = haxe.MainLoop.pending;
  local now = Sys.time();
  local wait = 1e9;
  while (e ~= nil) do 
    local next = e.next;
    local wt = e.nextRun - now;
    if ((e.nextRun < 0) or (wt <= 0)) then 
      wait = 0;
      if (e.f ~= nil) then 
        e:f();
      end;
    else
      if (wait > wt) then 
        wait = wt;
      end;
    end;
    e = next;
    end;
  do return wait end;
end

haxe.io.Bytes.new = function(length,b) 
  local self = _hx_new(haxe.io.Bytes.prototype)
  haxe.io.Bytes.super(self,length,b)
  return self
end
haxe.io.Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
haxe.io.Bytes.__name__ = true
haxe.io.Bytes.alloc = function(length) 
  local a = Array.new();
  local _g1 = 0;
  local _g = length;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    a:push(0);
    end;
  do return haxe.io.Bytes.new(length,a) end;
end
haxe.io.Bytes.ofString = function(s) 
  local _g = _hx_tab_array({ }, 0);
  local _g2 = 0;
  local _g1 = s.length;
  while (_g2 < _g1) do 
    _g2 = _g2 + 1;
    local c = _g2 - 1;
    _g:push(_G.string.byte(s,c + 1));
    end;
  local bytes = _g;
  do return haxe.io.Bytes.new(bytes.length,bytes) end;
end
haxe.io.Bytes.prototype = _hx_a(
  'blit', function(self,pos,src,srcpos,len) 
    if (((((pos < 0) or (srcpos < 0)) or (len < 0)) or ((pos + len) > self.length)) or ((srcpos + len) > src.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b1 = self.b;
    local b2 = src.b;
    if ((b1 == b2) and (pos > srcpos)) then 
      local i = len;
      while (i > 0) do 
        i = i - 1;
        b1[i + pos] = b2[i + srcpos];
        end;
      do return end;
    end;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i1 = _g1 - 1;
      b1[i1 + pos] = b2[i1 + srcpos];
      end;
  end,
  'sub', function(self,pos,len) 
    if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    do return haxe.io.Bytes.new(len,self.b:slice(pos,pos + len)) end
  end,
  'getString', function(self,pos,len) 
    if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b = self.b.length;
    local begin = lua.Boot.__cast((function() 
      local _hx_1
      if (Math.isNaN(pos) or Math.isNaN(b)) then 
      _hx_1 = (0/0); else 
      _hx_1 = _G.math.min(pos,b); end
      return _hx_1
    end )() , Int);
    local a = pos + len;
    local b1 = self.b.length;
    local _end = lua.Boot.__cast((function() 
      local _hx_2
      if (Math.isNaN(a) or Math.isNaN(b1)) then 
      _hx_2 = (0/0); else 
      _hx_2 = _G.math.min(a,b1); end
      return _hx_2
    end )() , Int);
    local _g = _hx_tab_array({ }, 0);
    local _g2 = begin;
    local _g1 = _end;
    while (_g2 < _g1) do 
      _g2 = _g2 + 1;
      local i = _g2 - 1;
      _g:push(_G.string.char(self.b[i]));
      end;
    do return _g:join("") end
  end,
  'toString', function(self) 
    do return self:getString(0,self.length) end
  end
  ,'__class__',  haxe.io.Bytes
)

haxe.crypto.Base64.new = {}
haxe.crypto.Base64.__name__ = true
haxe.crypto.Base64.encode = function(bytes,complement) 
  if (complement == nil) then 
    complement = true;
  end;
  local str = haxe.crypto.BaseCode.new(haxe.crypto.Base64.BYTES):encodeBytes(bytes):toString();
  if (complement) then 
    local _g = _G.math.fmod(bytes.length, 3);
    local _g1 = _g;
    if (_g1) == 1 then 
      str = str .. "==";
    elseif (_g1) == 2 then 
      str = str .. "=";else end;
  end;
  do return str end;
end

haxe.crypto.BaseCode.new = function(base) 
  local self = _hx_new(haxe.crypto.BaseCode.prototype)
  haxe.crypto.BaseCode.super(self,base)
  return self
end
haxe.crypto.BaseCode.super = function(self,base) 
  local len = base.length;
  local nbits = 1;
  while (len > (_hx_bit.lshift(1,nbits))) do 
    nbits = nbits + 1;
    end;
  if ((nbits > 8) or (len ~= (_hx_bit.lshift(1,nbits)))) then 
    _G.error("BaseCode : base length must be a power of two.",0);
  end;
  self.base = base;
  self.nbits = nbits;
end
haxe.crypto.BaseCode.__name__ = true
haxe.crypto.BaseCode.prototype = _hx_a(
  'encodeBytes', function(self,b) 
    local nbits = self.nbits;
    local base = self.base;
    local size = Std.int((b.length * 8) / nbits);
    local out = haxe.io.Bytes.alloc(size + (function() 
      local _hx_1
      if ((_G.math.fmod(b.length * 8, nbits)) == 0) then 
      _hx_1 = 0; else 
      _hx_1 = 1; end
      return _hx_1
    end )());
    local buf = 0;
    local curbits = 0;
    local mask = (_hx_bit.lshift(1,nbits)) - 1;
    local pin = 0;
    local pout = 0;
    while (pout < size) do 
      while (curbits < nbits) do 
        curbits = curbits + 8;
        buf = _hx_bit.lshift(buf,8);
        pin = pin + 1;
        buf = _hx_bit.bor(buf,b.b[pin - 1]);
        end;
      curbits = curbits - nbits;
      pout = pout + 1;
      out.b[pout - 1] = _hx_bit.band(base.b[_hx_bit.band(_hx_bit.arshift(buf,curbits),mask)],255);
      end;
    if (curbits > 0) then 
      pout = pout + 1;
      out.b[pout - 1] = _hx_bit.band(base.b[_hx_bit.band(_hx_bit.lshift(buf,nbits - curbits),mask)],255);
    end;
    do return out end
  end,
  'initTable', function(self) 
    local tbl = Array.new();
    local _g = 0;
    while (_g < 256) do 
      _g = _g + 1;
      local i = _g - 1;
      tbl[i] = -1;
      end;
    local _g1 = 0;
    local _g2 = self.base.length;
    while (_g1 < _g2) do 
      _g1 = _g1 + 1;
      local i1 = _g1 - 1;
      tbl[self.base.b[i1]] = i1;
      end;
    self.tbl = tbl;
  end,
  'decodeBytes', function(self,b) 
    local nbits = self.nbits;
    local base = self.base;
    if (self.tbl == nil) then 
      self:initTable();
    end;
    local tbl = self.tbl;
    local size = _hx_bit.arshift(b.length * nbits,3);
    local out = haxe.io.Bytes.alloc(size);
    local buf = 0;
    local curbits = 0;
    local pin = 0;
    local pout = 0;
    while (pout < size) do 
      while (curbits < 8) do 
        curbits = curbits + nbits;
        buf = _hx_bit.lshift(buf,nbits);
        pin = pin + 1;
        local i = tbl[b.b[pin - 1]];
        if (i == -1) then 
          _G.error("BaseCode : invalid encoded char",0);
        end;
        buf = _hx_bit.bor(buf,i);
        end;
      curbits = curbits - 8;
      pout = pout + 1;
      out.b[pout - 1] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(buf,curbits),255),255);
      end;
    do return out end
  end
  ,'__class__',  haxe.crypto.BaseCode
)

haxe.crypto.Sha1.new = function() 
  local self = _hx_new(haxe.crypto.Sha1.prototype)
  haxe.crypto.Sha1.super(self)
  return self
end
haxe.crypto.Sha1.super = function(self) 
end
haxe.crypto.Sha1.__name__ = true
haxe.crypto.Sha1.encode = function(s) 
  local sh = haxe.crypto.Sha1.new();
  local h = sh:doEncode(haxe.crypto.Sha1.str2blks(s));
  do return sh:hex(h) end;
end
haxe.crypto.Sha1.str2blks = function(s) 
  local s1 = haxe.io.Bytes.ofString(s);
  local nblk = (_hx_bit.arshift(s1.length + 8,6)) + 1;
  local blks = Array.new();
  local _g1 = 0;
  local _g = nblk * 16;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    blks[i] = 0;
    end;
  local _g11 = 0;
  local _g2 = s1.length;
  while (_g11 < _g2) do 
    _g11 = _g11 + 1;
    local i1 = _g11 - 1;
    local p = _hx_bit.arshift(i1,2);
    local blks1 = blks;
    local p1 = p;
    blks1[p1] = _hx_bit.bor(blks1[p1],_hx_bit.lshift(s1.b[i1],24 - (_hx_bit.lshift((_hx_bit.band(i1,3)),3))));
    end;
  local i2 = s1.length;
  local p2 = _hx_bit.arshift(i2,2);
  local blks2 = blks;
  local p3 = p2;
  blks2[p3] = _hx_bit.bor(blks2[p3],_hx_bit.lshift(128,24 - (_hx_bit.lshift((_hx_bit.band(i2,3)),3))));
  blks[(nblk * 16) - 1] = s1.length * 8;
  do return blks end;
end
haxe.crypto.Sha1.prototype = _hx_a(
  'doEncode', function(self,x) 
    local w = Array.new();
    local a = 1732584193;
    local b = -271733879;
    local c = -1732584194;
    local d = 271733878;
    local e = -1009589776;
    local i = 0;
    while (i < x.length) do 
      local olda = a;
      local oldb = b;
      local oldc = c;
      local oldd = d;
      local olde = e;
      local j = 0;
      while (j < 80) do 
        if (j < 16) then 
          w[j] = x[i + j];
        else
          local num = _hx_bit.bxor(_hx_bit.bxor(_hx_bit.bxor(w[j - 3],w[j - 8]),w[j - 14]),w[j - 16]);
          w[j] = _hx_bit.bor(_hx_bit.lshift(num,1),_hx_bit.rshift(num,31));
        end;
        local t = ((((_hx_bit.bor(_hx_bit.lshift(a,5),_hx_bit.rshift(a,27))) + self:ft(j,b,c,d)) + e) + w[j]) + self:kt(j);
        e = d;
        d = c;
        c = _hx_bit.bor(_hx_bit.lshift(b,30),_hx_bit.rshift(b,2));
        b = a;
        a = t;
        j = j + 1;
        end;
      a = a + olda;
      b = b + oldb;
      c = c + oldc;
      d = d + oldd;
      e = e + olde;
      i = i + 16;
      end;
    do return _hx_tab_array({[0]=a, b, c, d, e }, 5) end
  end,
  'ft', function(self,t,b,c,d) 
    if (t < 20) then 
      do return _hx_bit.bor(_hx_bit.band(b,c),_hx_bit.band(_hx_bit.bnot(b),d)) end;
    end;
    if (t < 40) then 
      do return _hx_bit.bxor(_hx_bit.bxor(b,c),d) end;
    end;
    if (t < 60) then 
      do return _hx_bit.bor(_hx_bit.bor(_hx_bit.band(b,c),_hx_bit.band(b,d)),_hx_bit.band(c,d)) end;
    end;
    do return _hx_bit.bxor(_hx_bit.bxor(b,c),d) end
  end,
  'kt', function(self,t) 
    if (t < 20) then 
      do return 1518500249 end;
    end;
    if (t < 40) then 
      do return 1859775393 end;
    end;
    if (t < 60) then 
      do return -1894007588 end;
    end;
    do return -899497514 end
  end,
  'hex', function(self,a) 
    local str = "";
    local _g = 0;
    while (_g < a.length) do 
      local num = a[_g];
      _g = _g + 1;
      str = str .. StringTools.hex(num,8);
      end;
    do return str:toLowerCase() end
  end
  ,'__class__',  haxe.crypto.Sha1
)

haxe.ds.IntMap.new = function() 
  local self = _hx_new(haxe.ds.IntMap.prototype)
  haxe.ds.IntMap.super(self)
  return self
end
haxe.ds.IntMap.super = function(self) 
  self.h = _hx_e();
end
haxe.ds.IntMap.__name__ = true
haxe.ds.IntMap.__interfaces__ = {haxe.IMap}
haxe.ds.IntMap.prototype = _hx_a(
  'set', function(self,key,value) 
    self.h[key] = value;
  end,
  'get', function(self,key) 
    do return self.h[key] end
  end,
  'exists', function(self,key) 
    local o = self.h;
    local field = key;
    if (o.__fields__ ~= nil) then 
      do return o.__fields__[field] ~= nil end;
    else
      do return o[field] ~= nil end;
    end;
  end
  ,'__class__',  haxe.ds.IntMap
)

haxe.ds.StringMap.new = function() 
  local self = _hx_new(haxe.ds.StringMap.prototype)
  haxe.ds.StringMap.super(self)
  return self
end
haxe.ds.StringMap.super = function(self) 
  self.v = {}
  self.k = {}
end
haxe.ds.StringMap.__name__ = true
haxe.ds.StringMap.__interfaces__ = {haxe.IMap}
haxe.ds.StringMap.prototype = _hx_a(
  'set', function(self,key,value) 
    self.v[key] = value;
    self.k[key] = true;
  end,
  'get', function(self,key) 
    do return self.v[key] end
  end,
  'exists', function(self,key) 
    do return (self.k[key] or false) end
  end,
  'keys', function(self) 
    local cur = _hx_tab_array({ }, 0);
    for _k,_v in pairs(self.k) do
			if(_v)then cur:push(_k) end
		end;
    do return _hx_o({__fields__={next=true,hasNext=true},next=function() 
      local ret = cur:pop();
      do return ret end;
    end,hasNext=function() 
      do return cur.length > 0 end;
    end}) end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local it = self:keys();
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return it:hasNext() end;
    end,next=function() 
      do return _gthis.v[it:next()] end;
    end}) end
  end
  ,'__class__',  haxe.ds.StringMap
)

haxe.io.BytesBuffer.new = function() 
  local self = _hx_new(haxe.io.BytesBuffer.prototype)
  haxe.io.BytesBuffer.super(self)
  return self
end
haxe.io.BytesBuffer.super = function(self) 
  self.b = Array.new();
end
haxe.io.BytesBuffer.__name__ = true
haxe.io.BytesBuffer.prototype = _hx_a(
  'getBytes', function(self) 
    local bytes = haxe.io.Bytes.new(self.b.length,self.b);
    self.b = nil;
    do return bytes end
  end
  ,'__class__',  haxe.io.BytesBuffer
)

haxe.io.Eof.new = {}
haxe.io.Eof.__name__ = true
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
  ,'__class__',  haxe.io.Eof
)
_hxClasses["haxe.io.Error"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
haxe.io.Error = _hxClasses["haxe.io.Error"];
haxe.io.Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = haxe.io.Error},2)

haxe.io.Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = haxe.io.Error},2)

haxe.io.Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = haxe.io.Error},2)

haxe.io.Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=haxe.io.Error}, 3); return _x; end 

lua.Boot.new = {}
lua.Boot.__name__ = true
lua.Boot.getClass = function(o) 
  if (lua.Boot.__instanceof(o,Array)) then 
    do return Array end;
  else
    local cl = o.__class__;
    if (cl ~= nil) then 
      do return cl end;
    else
      do return nil end;
    end;
  end;
end
lua.Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return lua.Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return true end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == lua.Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == lua.UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    if (lua.Boot.extendsOrImplements(lua.Boot.getClass(o),cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_1
      if (cl == Class) then 
      _hx_1 = o.__name__ ~= nil; else 
      _hx_1 = false; end
      return _hx_1
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Enum) then 
      _hx_2 = o.__ename__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.__cast = function(o,t) 
  if (lua.Boot.__instanceof(o,t)) then 
    do return o end;
  else
    _G.error("Cannot cast " .. Std.string(o) .. " to " .. Std.string(t),0);
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g1 = 1;
        local _g = _hx_table.maxn(intf) + 1;
        while (_g1 < _g) do 
          _g1 = _g1 + 1;
          local i = _g1 - 1;
          if (lua.Boot.extendsOrImplements(intf[i],cl2)) then 
            do return true end;
          end;
          end;
      end;
    end;
  end;
  do return lua.Boot.extendsOrImplements(cl1.__super__,cl2) end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function() 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function() 
    do return cur_val ~= nil end;
  end}) end;
end

lua.UserData.new = {}
lua.UserData.__name__ = true

lua.Thread.new = {}
lua.Thread.__name__ = true
lua.lib.luasocket = {}
lua.lib.luasocket.Socket = _G.require("socket")

tink._Url.Url_Impl_.new = {}
tink._Url.Url_Impl_.__name__ = true
tink._Url.Url_Impl_.toString = function(this1) 
  local _g = this1.scheme;
  if (_g == nil) then 
    do return this1.payload end;
  else
    do return "" .. this1.scheme .. ":" .. this1.payload end;
  end;
end
tink._Url.Url_Impl_.parse = function(s) 
  if (s == nil) then 
    do return tink._Url.Url_Impl_.parse("") end;
  end;
  s = StringTools.trim(s);
  if (StringTools.startsWith(s,"data:")) then 
    local this1 = _hx_o({__fields__={scheme=true,payload=true},scheme="data",payload=s:substr(5)});
    do return this1 end;
  end;
  local FORMAT = EReg.new("^(([a-zA-Z][a-zA-Z0-9\\-]*):)?((//(([^@/]+)@)?([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?)$","");
  local HOST = EReg.new("^(\\[(.*)\\]|([^:]*))(:(\\d*))?$","");
  FORMAT:match(s);
  local hosts;
  local _g = FORMAT:matched(7);
  if (_g == nil) then 
    hosts = _hx_tab_array({ }, 0);
  else
    local v = _g;
    local _g1 = _hx_tab_array({ }, 0);
    local _g11 = 0;
    local _g2 = v:split(",");
    while (_g11 < _g2.length) do 
      local host = _g2[_g11];
      _g11 = _g11 + 1;
      HOST:match(host);
      local host1;
      local _g3 = HOST:matched(2);
      local _g4 = HOST:matched(3);
      if (_g3 == nil) then 
        local ipv4 = _g4;
        host1 = ipv4;
      else
        if (_g4 == nil) then 
          local ipv6 = _g3;
          host1 = "[" .. ipv6 .. "]";
        else
          _G.error("assert",0);
        end;
      end;
      local port;
      local _g5 = HOST:matched(5);
      if (_g5 == nil) then 
        port = nil;
      else
        local v1 = _g5;
        local _g51 = Std.parseInt(v1);
        if (_g51 == nil) then 
          _G.error("Invalid port",0);
        else
          local p = _g51;
          port = p;
        end;
      end;
      local this2;
      if (port == nil) then 
        this2 = host1;
      else
        if ((port > 65535) or (port <= 0)) then 
          _G.error("Invalid port",0);
        else
          this2 = "" .. host1 .. ":" .. port;
        end;
      end;
      _g1:push(this2);
      end;
    hosts = _g1;
  end;
  local path = FORMAT:matched(8);
  if ((hosts.length > 0) and (path:charAt(0) ~= "/")) then 
    path = "/" .. path;
  end;
  local this3 = _hx_o({__fields__={scheme=true,payload=true,host=true,hosts=true,auth=true,path=true,query=true,hash=true},scheme=FORMAT:matched(2),payload=FORMAT:matched(3),host=hosts[0],hosts=hosts,auth=FORMAT:matched(6),path=tink.url._Path.Path_Impl_.ofString(path),query=FORMAT:matched(10),hash=FORMAT:matched(12)});
  do return this3 end;
end

tink.core.TypedError.new = function(code,message,pos) 
  local self = _hx_new(tink.core.TypedError.prototype)
  tink.core.TypedError.super(self,code,message,pos)
  return self
end
tink.core.TypedError.super = function(self,code,message,pos) 
  if (code == nil) then 
    code = 500;
  end;
  self.code = code;
  self.message = message;
  self.pos = pos;
  self.exceptionStack = _hx_tab_array({ }, 0);
  self.callStack = _hx_tab_array({ }, 0);
end
tink.core.TypedError.__name__ = true
tink.core.TypedError.withData = function(code,message,data,pos) 
  do return tink.core.TypedError.typed(code,message,data,pos) end;
end
tink.core.TypedError.typed = function(code,message,data,pos) 
  local ret = tink.core.TypedError.new(code,message,pos);
  ret.data = data;
  do return ret end;
end
tink.core.TypedError.catchExceptions = function(f,report,pos) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      do return tink.core.Outcome.Success(f()) end;
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    if( lua.Boot.__instanceof(_hx_1,tink.core.TypedError) ) then 
      local e = _hx_1
      do return tink.core.Outcome.Failure(e) end;
    else
    local e1 = _hx_1
    do return tink.core.Outcome.Failure((function() 
      local _hx_2
      if (report == nil) then 
      _hx_2 = tink.core.TypedError.withData(nil,"Unexpected Error",e1,pos); else 
      _hx_2 = report(e1); end
      return _hx_2
    end )()) end;
     end 
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
tink.core.TypedError.reporter = function(code,message,pos) 
  do return function(e) 
    do return tink.core.TypedError.withData(code,message,e,pos) end;
  end end;
end
tink.core.TypedError.rethrow = function(any) 
  _G.error(any,0);
end
tink.core.TypedError.prototype = _hx_a(
  'printPos', function(self) 
    do return self.pos.className .. "." .. self.pos.methodName .. ":" .. self.pos.lineNumber end
  end,
  'toString', function(self) 
    local ret = "Error#" .. self.code .. ": " .. self.message;
    if (self.pos ~= nil) then 
      ret = ret .. (" @ " .. self:printPos());
    end;
    do return ret end
  end,
  'throwSelf', function(self) 
    _G.error(self,0);
  end
  ,'__class__',  tink.core.TypedError
)
_hxClasses["tink.core.Outcome"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Success","Failure"},2)}
tink.core.Outcome = _hxClasses["tink.core.Outcome"];
tink.core.Outcome.Success = function(data) local _x = _hx_tab_array({[0]="Success",0,data,__enum__=tink.core.Outcome}, 3); return _x; end 
tink.core.Outcome.Failure = function(failure) local _x = _hx_tab_array({[0]="Failure",1,failure,__enum__=tink.core.Outcome}, 3); return _x; end 

tink.url._Path.Path_Impl_.new = {}
tink.url._Path.Path_Impl_.__name__ = true
tink.url._Path.Path_Impl_.ofString = function(s) 
  local this1 = tink.url._Path.Path_Impl_.normalize(s);
  do return this1 end;
end
tink.url._Path.Path_Impl_.normalize = function(s) 
  s = StringTools.trim(StringTools.replace(s,"\\","/"));
  if (s == ".") then 
    do return "./" end;
  end;
  local isDir = (StringTools.endsWith(s,"/..") or StringTools.endsWith(s,"/")) or StringTools.endsWith(s,"/.");
  local parts = _hx_tab_array({ }, 0);
  local isAbsolute = StringTools.startsWith(s,"/");
  local up = 0;
  local _g = 0;
  local _g1 = s:split("/");
  while (_g < _g1.length) do 
    local part = _g1[_g];
    _g = _g + 1;
    local _g2 = StringTools.trim(part);
    local _g21 = _g2;
    if (_g21) == "" then 
    elseif (_g21) == "." then 
    elseif (_g21) == ".." then 
      if (parts:pop() == nil) then 
        up = up + 1;
      end;else
    local v = _g2;
    parts:push(v); end;
    end;
  if (isAbsolute) then 
    parts:unshift("");
  else
    local _g11 = 0;
    local _g3 = up;
    while (_g11 < _g3) do 
      _g11 = _g11 + 1;
      local i = _g11 - 1;
      parts:unshift("..");
      end;
  end;
  if (isDir) then 
    parts:push("");
  end;
  do return parts:join("/") end;
end
_hx_bit_clamp = function(v) 
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end
pcall(require, 'bit')
if bit then
  _hx_bit = bit
elseif bit32 then
  local _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

EReg.FLAGS = lua.lib.lrexlib.Rex.flags()
haxe.EntryPoint.sleepLock = haxe._EntryPoint.Lock.new()
haxe.EntryPoint.mutex = haxe._EntryPoint.Mutex.new()
haxe.EntryPoint.pending = Array.new()
haxe.EntryPoint.threadCount = 0
haxe.crypto.Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe.crypto.Base64.BYTES = haxe.io.Bytes.ofString(haxe.crypto.Base64.CHARS)
lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
do

Chocolate.App = Chocolate.new();
Chocolate.WebSocket = WebSocket.new();
if (lua.lib.lrexlib.Rex == nil) then 
  _G.error("Rex is missing.  Please install lrexlib-pcre.",0);
end;
Fio._module = require("fio");
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
Chocolate.App = Chocolate.new();
Chocolate.WebSocket = WebSocket.new();
if (lua.lib.lrexlib.Rex == nil) then 
  _G.error("Rex is missing.  Please install lrexlib-pcre.",0);
end;
Fio._module = require("fio");
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
end
_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else 
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end
_hx_funcToField = function(f)
  if type(f) == 'function' then 
    return function(self,...) 
      return f(...) 
    end
  else 
    return f
  end
end
_hx_print = print or (function() end)
_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

  TestZephyr.main();
  haxe.EntryPoint.run();

return _hx_exports
