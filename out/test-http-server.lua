-- Generated by Haxe 3.4.0
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local Array = _hx_e()
local HttpContext = _hx_e()
local IHandler = _hx_e()
local HttpHandler = _hx_e()
local HttpMethod = _hx_e()
local HttpRequest = _hx_e()
local IChannel = _hx_e()
local IWriteChannel = _hx_e()
local HttpResponse = _hx_e()
local HttpServer = _hx_e()
local IReadChannel = _hx_e()
local IRWChannel = _hx_e()
local Peer = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringTools = _hx_e()
local TcpSocket = _hx_e()
local TestHttpServer = _hx_e()
local Type = _hx_e()
local haxe = {}
haxe.IMap = _hx_e()
haxe.Log = _hx_e()
haxe.ds = {}
haxe.ds.StringMap = _hx_e()
haxe.io = {}
haxe.io.Bytes = _hx_e()
haxe.io.Eof = _hx_e()
local lua = {}
lua.Boot = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self,0);
end
Array.__name__ = true
Array.prototype = _hx_a(
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
)

HttpContext.new = function(request,response) 
  local self = _hx_new()
  HttpContext.super(self,request,response)
  return self
end
HttpContext.super = function(self,request,response) 
  self.Request = request;
  self.Response = response;
end
HttpContext.__name__ = true

IHandler.new = {}
IHandler.__name__ = true

HttpHandler.new = function() 
  local self = _hx_new(HttpHandler.prototype)
  HttpHandler.super(self)
  return self
end
HttpHandler.super = function(self) 
end
HttpHandler.__name__ = true
HttpHandler.__interfaces__ = {IHandler}
HttpHandler.prototype = _hx_a(
  'CanProcess', function(self,request) 
    do return true end
  end,
  'Process', function(self,context) 
    context.Response:WriteString("HTTP/1.1 200 OK\n");
    context.Response:WriteString("Content-Length: 4");
    context.Response:WriteString("\n\n");
    context.Response:WriteString("GOOD\n");
  end
)
_hxClasses["HttpMethod"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="get","post","put","delete"},4)}
HttpMethod = _hxClasses["HttpMethod"];
HttpMethod.get = _hx_tab_array({[0]="get",0,__enum__ = HttpMethod},2)

HttpMethod.post = _hx_tab_array({[0]="post",1,__enum__ = HttpMethod},2)

HttpMethod.put = _hx_tab_array({[0]="put",2,__enum__ = HttpMethod},2)

HttpMethod.delete = _hx_tab_array({[0]="delete",3,__enum__ = HttpMethod},2)


HttpRequest.new = function(channel) 
  local self = _hx_new(HttpRequest.prototype)
  HttpRequest.super(self,channel)
  return self
end
HttpRequest.super = function(self,channel) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      self:ReadHeaders(channel);
      self:ReadBody(channel);
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    local e = _hx_1
    _G.error("Bad request",0);
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
HttpRequest.__name__ = true
HttpRequest.prototype = _hx_a(
  'ReadHeaders', function(self,channel) 
    local line = StringTools.trim(channel:ReadUntil("\n"));
    local parts = line:split(" ");
    if (parts.length ~= 3) then 
      _G.error("Bad request",0);
    end;
    self.Method = Type.createEnum(HttpMethod,parts[0]:toLowerCase(),nil);
    self.Resource = parts[1];
    haxe.Log.trace(self.Method,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="HttpRequest.hx",lineNumber=42,className="HttpRequest",methodName="ReadHeaders"}));
    haxe.Log.trace(self.Resource,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="HttpRequest.hx",lineNumber=43,className="HttpRequest",methodName="ReadHeaders"}));
    self.Headers = haxe.ds.StringMap.new();
    line = StringTools.trim(channel:ReadUntil("\n"));
    while (line.length > 0) do 
      local head = line:split(": ");
      if (head.length < 2) then 
        _G.error("Bad request",0);
      end;
      local v = head[1];
      local _this = self.Headers;
      local key = head[0];
      _this.v[key] = v;
      _this.k[key] = true;
      line = StringTools.trim(channel:ReadUntil("\n"));
      end;
  end,
  'ReadBody', function(self,channel) 
    self.Body = nil;
    if (self.Method == HttpMethod.get) then 
      do return end;
    end;
    local this1 = self.Headers;
    if ((this1.k["Content-Length"] or false)) then 
      local this2 = self.Headers;
      local len = Std.parseInt(this2.v["Content-Length"]);
      self.Body = channel:Read(len);
    else
      local this3 = self.Headers;
      local tmp = this3.v["Transfer-Encoding"] == "chunked";
    end;
  end
)

IChannel.new = {}
IChannel.__name__ = true

IWriteChannel.new = {}
IWriteChannel.__name__ = true
IWriteChannel.__interfaces__ = {IChannel}

HttpResponse.new = function(channel) 
  local self = _hx_new(HttpResponse.prototype)
  HttpResponse.super(self,channel)
  return self
end
HttpResponse.super = function(self,channel) 
  self._channel = channel;
end
HttpResponse.__name__ = true
HttpResponse.__interfaces__ = {IWriteChannel}
HttpResponse.prototype = _hx_a(
  'WriteString', function(self,data) 
    do return self._channel:WriteString(data) end
  end,
  'Close', function(self) 
  end
)

HttpServer.new = function() 
  local self = _hx_new(HttpServer.prototype)
  HttpServer.super(self)
  return self
end
HttpServer.super = function(self) 
  self._socket = TcpSocket.new();
  self._handlers = Array.new();
end
HttpServer.__name__ = true
HttpServer.prototype = _hx_a(
  'AddHandler', function(self,handler) 
    self._handlers:push(handler);
  end,
  'Bind', function(self,host,port) 
    local _gthis = self;
    if (self._handlers.length < 1) then 
      _G.error("No handlers",0);
    end;
    self._socket:Bind(host,port,function(p,c) 
      _gthis:ProcessClient(p,c);
    end);
  end,
  'ProcessClient', function(self,peer,channel) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        local response = HttpResponse.new(channel);
        while (true) do 
          local request = HttpRequest.new(channel);
          local context = HttpContext.new(request,response);
          local _g = 0;
          local _g1 = self._handlers;
          while (_g < _g1.length) do 
            local h = _g1[_g];
            _g = _g + 1;
            if (h:CanProcess(request)) then 
              h:Process(context);
            end;
            end;
          end;
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      local e = _hx_1
      haxe.Log.trace(e,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="HttpServer.hx",lineNumber=56,className="HttpServer",methodName="ProcessClient"}));
      channel:Close();
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end
)

IReadChannel.new = {}
IReadChannel.__name__ = true
IReadChannel.__interfaces__ = {IChannel}

IRWChannel.new = {}
IRWChannel.__name__ = true
IRWChannel.__interfaces__ = {IWriteChannel,IReadChannel}

Peer.new = function() 
  local self = _hx_new()
  Peer.super(self)
  return self
end
Peer.super = function(self) 
end
Peer.__name__ = true

Reflect.new = {}
Reflect.__name__ = true
Reflect.field = function(o,field) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      do return o[field] end;
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    local e = _hx_1
    do return nil end;
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end

String.new = {}
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'toLowerCase', function(self) 
    do return _G.string.lower(self) end
  end,
  'split', function(self,delimiter) 
    local idx = 1;
    local ret = _hx_tab_array({ }, 0);
    local delim_offset = (function() 
      local _hx_1
      if (delimiter.length > 0) then 
      _hx_1 = delimiter.length; else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (delimiter.length > 0) then 
        newidx = _G.string.find(self,delimiter,idx,true);
      else
        if (idx >= self.length) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(self,idx,newidx - 1);
        ret:push(match);
        idx = newidx + delimiter.length;
      else
        ret:push(_G.string.sub(self,idx,_G.string.len(self)));
        idx = nil;
      end;
      end;
    do return ret end
  end,
  'toString', function(self) 
    do return self end
  end,
  'charCodeAt', function(self,index) 
    do return _G.string.byte(self,index + 1) end
  end,
  'substr', function(self,pos,len) 
    if ((len == nil) or (len > (pos + self.length))) then 
      len = self.length;
    else
      if (len < 0) then 
        len = self.length + len;
      end;
    end;
    if (pos < 0) then 
      pos = self.length + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(self,pos + 1,pos + len) end
  end
)

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x,"^ *[%-+]*0[xX][%da-FA-F]*");
  if (hexMatch ~= nil) then 
    do return _G.tonumber(hexMatch:substr(2),16) end;
  else
    local intMatch = _G.string.match(x,"^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end

StringTools.new = {}
StringTools.__name__ = true
StringTools.isSpace = function(s,pos) 
  if (((s.length == 0) or (pos < 0)) or (pos >= s.length)) then 
    do return false end;
  end;
  local c = s:charCodeAt(pos);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = s.length;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s,r)) do 
    r = r + 1;
    end;
  if (r > 0) then 
    do return s:substr(r,l - r) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = s.length;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s,(l - r) - 1)) do 
    r = r + 1;
    end;
  if (r > 0) then 
    do return s:substr(0,l - r) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end

TcpSocket.new = function(luaSock) 
  local self = _hx_new(TcpSocket.prototype)
  TcpSocket.super(self,luaSock)
  return self
end
TcpSocket.super = function(self,luaSock) 
  if (luaSock ~= nil) then 
    self._sock = luaSock;
  else
    self._module = require("socket");
  end;
end
TcpSocket.__name__ = true
TcpSocket.__interfaces__ = {IRWChannel}
TcpSocket.prototype = _hx_a(
  'Read', function(self,size) 
    local res = self._sock:read(size);
    if (res == "") then 
      do return nil end;
    end;
    if (res == nil) then 
      _G.error("Socket error",0);
    end;
    do return haxe.io.Bytes.ofString(res) end
  end,
  'WriteString', function(self,data) 
    do return self._sock:write(data) end
  end,
  'ReadUntil', function(self,delimeter) 
    local res = self._sock:read(delimeter);
    if (res == "") then 
      do return nil end;
    end;
    if (res == nil) then 
      _G.error("Socket error",0);
    end;
    do return res end
  end,
  'Close', function(self) 
    self._sock:shutdown();
  end,
  'Bind', function(self,host,port,handler) 
    self._sock = self._module.tcp_server(host,port,function(s,e) 
      local tmp = Peer.new();
      handler(tmp,TcpSocket.new(s));
    end);
  end
)

TestHttpServer.new = {}
TestHttpServer.__name__ = true
TestHttpServer.main = function() 
  local httpServer = HttpServer.new();
  httpServer:AddHandler(HttpHandler.new());
  httpServer:Bind("*",8082);
end

Type.new = {}
Type.__name__ = true
Type.createEnum = function(e,constr,params) 
  local f = Reflect.field(e,constr);
  if (f == nil) then 
    _G.error("No such constructor " .. constr,0);
  end;
  if (Reflect.isFunction(f)) then 
    if (params == nil) then 
      _G.error("Constructor " .. constr .. " need parameters",0);
    end;
    local func = f;
    if ((params == nil) or (params.length == 0)) then 
      do return func(nil) end;
    else
      local self_arg = false;
      local new_args = ({});
      local _g1 = 0;
      local _g = params.length;
      while (_g1 < _g) do 
        _g1 = _g1 + 1;
        local i = _g1 - 1;
        new_args[i + 1] = params[i];
        end;
      if (self_arg) then 
        do return func(nil,_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
      else
        do return func(_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
      end;
    end;
  end;
  if ((params ~= nil) and (params.length ~= 0)) then 
    _G.error("Constructor " .. constr .. " does not need parameters",0);
  end;
  do return f end;
end

haxe.IMap.new = {}
haxe.IMap.__name__ = true

haxe.Log.new = {}
haxe.Log.__name__ = true
haxe.Log.trace = function(v,infos) 
  local str = nil;
  if (infos ~= nil) then 
    str = infos.fileName .. ":" .. infos.lineNumber .. ": " .. Std.string(v);
    if (infos.customParams ~= nil) then 
      str = str .. ("," .. infos.customParams:join(","));
    end;
  else
    str = v;
  end;
  if (str == nil) then 
    str = "null";
  end;
  _hx_print(str);
end

haxe.ds.StringMap.new = function() 
  local self = _hx_new()
  haxe.ds.StringMap.super(self)
  return self
end
haxe.ds.StringMap.super = function(self) 
  self.v = {}
  self.k = {}
end
haxe.ds.StringMap.__name__ = true
haxe.ds.StringMap.__interfaces__ = {haxe.IMap}

haxe.io.Bytes.new = function(length,b) 
  local self = _hx_new()
  haxe.io.Bytes.super(self,length,b)
  return self
end
haxe.io.Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
haxe.io.Bytes.__name__ = true
haxe.io.Bytes.ofString = function(s) 
  local _g = _hx_tab_array({ }, 0);
  local _g2 = 0;
  local _g1 = s.length;
  while (_g2 < _g1) do 
    _g2 = _g2 + 1;
    local c = _g2 - 1;
    _g:push(_G.string.byte(s,c + 1));
    end;
  local bytes = _g;
  do return haxe.io.Bytes.new(bytes.length,bytes) end;
end

haxe.io.Eof.new = {}
haxe.io.Eof.__name__ = true
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
)

lua.Boot.new = {}
lua.Boot.__name__ = true
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function() 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function() 
    do return cur_val ~= nil end;
  end}) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
do

String.__name__ = true;
Array.__name__ = true;
String.__name__ = true;
Array.__name__ = true;
end
_hx_print = print or (function() end)
_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;
TestHttpServer.main()
return _hx_exports
